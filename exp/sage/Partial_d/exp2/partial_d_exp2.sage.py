

# This file was *autogenerated* from the file partial_d_exp2.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_0p3 = RealNumber('0.3'); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_0x56a8f8cbc72ff68e67c72718bd16d7e98150aea08780f6c4f532d20ca3c92a0fb07c959e008cbcbeac744854bc4203eb9b2996e9cf630133bc38952a2c17c27d = Integer(0x56a8f8cbc72ff68e67c72718bd16d7e98150aea08780f6c4f532d20ca3c92a0fb07c959e008cbcbeac744854bc4203eb9b2996e9cf630133bc38952a2c17c27d); _sage_const_0x3 = Integer(0x3); _sage_const_0x594b6c9631c4987f588399f22466b51fc48ed449b8aae0309b5736ef0b741893 = Integer(0x594b6c9631c4987f588399f22466b51fc48ed449b8aae0309b5736ef0b741893); _sage_const_0p5 = RealNumber('0.5'); _sage_const_7 = Integer(7); _sage_const_255 = Integer(255)
def partial_p(p0, kbits, n):
    PR = PolynomialRing(Zmod(n), names=('x',)); (x,) = PR._first_ngens(1)
    nbits = n.nbits()

    f = _sage_const_2 **kbits*x + p0
    f = f.monic()
    roots = f.small_roots(X=_sage_const_2 **(nbits//_sage_const_2 -kbits), beta=_sage_const_0p3 )  # find root < 2^(nbits//2-kbits) with factor >= n^0.3
    if roots:
        x0 = roots[_sage_const_0 ]
        p = gcd(_sage_const_2 **kbits*x0 + p0, n)
        return ZZ(p)

def find_p(d0, kbits, e, n):
    X = var('X')

    for k in range(_sage_const_1 , e+_sage_const_1 ):
        results = solve_mod([e*d0*X - k*X*(n-X+_sage_const_1 ) + k*n == X], _sage_const_2 **kbits)
        for x in results:
            p0 = ZZ(x[_sage_const_0 ])
            p = partial_p(p0, kbits, n)
            if p:
                return p


if __name__ == '__main__':
    n = _sage_const_0x56a8f8cbc72ff68e67c72718bd16d7e98150aea08780f6c4f532d20ca3c92a0fb07c959e008cbcbeac744854bc4203eb9b2996e9cf630133bc38952a2c17c27d  
    e = _sage_const_0x3 
    d = _sage_const_0x594b6c9631c4987f588399f22466b51fc48ed449b8aae0309b5736ef0b741893 
    beta = _sage_const_0p5 
    epsilon = beta**_sage_const_2 /_sage_const_7 

    nbits = n.nbits()
    kbits = _sage_const_255 
    d0 = d & (_sage_const_2 **kbits-_sage_const_1 )
    print("lower %d bits (of %d bits) is given" % (kbits, nbits))

    p = find_p(d0, kbits, e, n)
    print("found p: %d" % p)
    q = n//p
    print("d的低位为：",hex(d))
    print("完整的d为：",hex(inverse_mod(e, (p-_sage_const_1 )*(q-_sage_const_1 ))))

